# C#面试题

## 目录
- [C#面试题](#c面试题)
  - [目录](#目录)
  - [逻辑运算](#逻辑运算)
  - [进制相关](#进制相关)
  - [数据类型](#数据类型)
  - [语法规则](#语法规则)
  - [类与对象](#类与对象)
  - [委托与事件](#委托与事件)


## 逻辑运算
1. 1 == 1 || 2==2 && 2 == 3的结果是True还是False？(1分)   
   解析：正确答案为True。因为&&的优先级比||高，所以先运算2==2 && 3 == 3，得到False，这个结果再和1 == 1进行或运算，得到True。
   如果你误以为||与&&的优先级相同，那么你会先运算1 == 1 || 2== 2，得到True，这个结果再和2 == 3进行与运算，得到False。  
    题外话：在工作中，经常会在if语句中判断多个条件的组合。要先搞清楚业务逻辑，然后用代码表达条件组合时要表达正确，我见过一些新手不知道
    这个知识点导致条件判断出了问题，然后用了很多括号来强行纠正。

2. 理解以下代码：
   ```
    int a = 1;
    int b = 0;
    int c = 100;
    if (a == 1 || (c=99) < 100)
    {
        Console.WriteLine(b);
    }
   ```
   问：程序输出？  
    解析：100。这里主要考察在if分支判断时的自动优化情况。在if分支判断表达式时，如果表达式中第一个逻辑运算符为||，并且“||”前面的结果是True，
    那么程序会忽略（不执行）“||”后面的所有内容，直接返回True。因为对于“||”来说，只要有一边的结果为True，无论另一边结果是什么，最终都返回True；
    同理，如果表达式中第一个逻辑运算符为&&，并且“&&”前面的结果是False，那么会忽略（不执行）“&&”后面的所有内容，直接返回False。  
    题外话：我想强调的是c=99是不执行的，在工作实践中，这里可能会是一些重要的方法调用，如果因为写的人不知道这个知识点而导致了这个错误，
    那真是不应该。

3. 现在有三个bool变量A,B,C，我想写一个if语句，if里面的判断要判断出这三个变量中有且仅有一个为true，怎么做？  
   答案1：if(A && !B && !C || !A && B && !C || !A && !B && C) （1分）  
   答案2：if((A ? 1 : 0) + (B ? 1 : 0) + (C ? 1 : 0) == 1) (3分)  
   为什么答案2比答案1好？  
   答案1是把每种情况枚举出来进行判断，每个变量都访问了三遍，那么如果不止三个变量呢，甚至要求判断有且仅有两个为true呢？是不是写得更繁琐和重复了。比较优雅的方式就是把每个bool变量的值转换为1/0（true为1，false为0），加起来看看true的个数是不是我想要的。如果你觉得三元表达式写起来比较麻烦，也可以写个方法封装一下，在C/C++中因为bool变量的值本身就契合true为1，false为0，所以可以直接把变量的值相加，但在java/C#中就需要多做一步转换。

## 进制相关

1. Int32类型的十进制与十六进制如何互转（不通过格式化字符串方式）？（2分）  
    解析：  
    （首先如果答者直接表明这样的意思：进制只是数字的一种表现形式，其核心是存在内存/字节里的二进制内容，那么可以不用理会后面的内容直接得2分。）  
    既然是Int32类型，那么在内存中所占的就是四个字节，我们无法直接获取这四个字节的真实内容，但是
    我们可以通过计算来得到一个模拟的内存/字节数据（讲到这点给1分），具体地，我们可以通过对数据做位移和位运算操作（讲到这点给1分）来得到
    字节内容，有了该内容后，之后想转换成几进制，只需要按照一定的转换规则进行计算即可。  
    题外话：在网络编程（如串口通信）中，我们经常要把信息转换成字节数组进行传输，以及接收到后再将其转换回我们能看得懂的有效信息。  

## 数据类型 
1. 如何判断浮点数与某个数值相等？（1分）  
    解析：浮点数因为精度问题，导致在运算后得到的可能是精度很高的浮点数，比如0.1+0.2=0.300000000000004，而不等于0.3。如果要判断浮点数与
    某个数值相等，需要将该浮点数减去该数值，然后获取它的绝对值，是否小于一个精度误差范围，如0.000000000001，在这个误差范围内则认为是相等。  
    题外话：真的有新手直接用==判断，其实这个知识点不仅适用于C#，C/C++也适用。

2. int?和int有什么区别（3分）  
    解析：  
    1. int?可以为Null，int不可以(1分)
    2. int可以隐式转换为int?，但int?只能显式转换为int，且转换前最好判断是否为Null(1分)
    3. 如果强制转换时int?为空，会出现什么结果？
    4. int?是结构体（Nullable< T >），int是简单数据类型(1分)
    题外话：int?挺常用的，尤其是在EF中，许多实体模型中的字段被声明为可空值类型。

3. 说一下什么是装箱和拆箱（1分）  
    解析：装箱就是把值类型转换成引用类型，拆箱就是把装箱了的引用类型转换成值类型。装箱和拆箱因为涉及到申请内存空间和内存拷贝操作，
    所以会影响一些性能。（了解即可）

4. string转int怎么转？如果string是”abc”，会发生什么？（3分）
    解析：调用方法int.parse/tryparse进行转化（得1分）。如果调用parse方法会报错；如果调用tryparse方法会返回false表示转换失败，一般推荐使用后者进行转换。

## 语法规则

1. 说一下ref和out关键字的异同点（3分）  
   不同点  
   1. 使用ref时，传入的参数必须初始化；而使用out时不用初始化（1分）
   2. out在退出方法时，所有out参数都必须被赋值；ref没有这个要求（1分）
    相同点：
    他们都是传递地址的。（1分）

2. 理解以下代码：
   ```
    string[] ints = { "1","2","3","4","5" };
    var some = ints.Where(i=>i.Contains("1")).ToList();
    foreach (var item in some)
    {
        item += "!";
    }
    Console.WriteLine(some[0]);
   ```
   该程序会输出？  
   解析：该程序无法通过编译。因为对于基本类型的foreach循环，是不允许去直接改变循环变量的值的。该知识点了解即可。

## 类与对象

1. 静态构造函数的执行时机(1分)  
   解析：在程序第一次访问到该类时执行。

2. 当存在有参构造函数时，隐式的无参构造函数还能调用吗（1分）  
   解析：不能。

3. 你知道属性吗？属性与公共成员变量相比有什么优势？属性的set与get访问器是做什么的？属性可以被重写吗，需要通过什么关键字来重写属性？（3分）  
   解析：属性与公共成员变量相比，可以控制其访问权限（1分），通过设置属性的set,get访问器，并且可以在set,get访问器中写一些逻辑代码，在设置
   或访问属性时触发执行这些代码（1分）。属性可以被重写，通过override关键字（1分）。

4. 如果我想在一个类里声明一个成员变量，这个变量只能被其子类内部访问到，那么我要将该成员变量的访问修饰符更改为？（1分）  
   解析：protected。（1分，了解即可）

5. 解释一下方法重写和重载的概念（2分）  
   解析：重载就是在同一个类中，有多个方法的方法名称相同，但参数列表不同，我们称这些方法重载了。调用这些方法时编译器会根据实际
   传入的参数选择与其匹配的方法执行。（1分）  
   重写就是子类中有一个与父类方法签名相同的方法，但其内部逻辑不一样。重写时子类里要对该方法修饰为override，父类里该方法也得是
   抽象方法或者虚方法。（1分）

6. 如何深拷贝一个类对象？方法越多越好（3分）  
   解析：
   1. 给类继承ICloneable接口，重写Clone方法。（1分）
   2. 通过序列化与反序列化，媒介可以是json，xml或者二进制（不一定可靠，比如xml序列化可能会丢失数据）。（1分）
   3. 通过反射调用类的构造函数（1分）
   
7. 在静态方法中可以访问非静态成员变量吗？反一下，在非静态方法中可以访问静态成员变量吗？（2分）  
   解析：静态方法中只能访问静态成员变量（1分）；但在非静态方法中可以访问静态成员变量（1分）。

## 委托与事件

1. 什么是委托，能否列举C#中已经定义好的委托类型  
   委托是C#中类型安全的，可以订阅一个或多个具有相同签名方法的函数指针。C#中的action，function都是已经定义好的委托类型。

2. 什么是事件，怎么自定义一个事件？  
   事件是对委托的一种封装，对于委托的访问权限做了一系列处理。  
   自定义事件：在类中声明一个自定义事件使用：event [ 委托类型 ] 事件名的形式来声明。  
   
